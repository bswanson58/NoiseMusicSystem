
## The Noise Music System ##
# System Overview #
The Noise Music system is a music management system focused on the inventory, perusal and playback of locally stored audio files. The primary component of the system is a desktop application offering full functionality for library management, configuration and playback of audio files. In addition there is an interface designed for living room usage offering a “ten foot” user interface with control though a standard television remote. Both applications may also be controlled with iOS or Android tablet interfaces featuring the capability to peruse and queue playback of content in the music library.

# Technical Overview #
The system is primarily authored in C# targeted at the .Net 4.5 framework. Architected with a modular design it leverages IOC to construct the appropriate components for the application being started. The MVVM design pattern is used exclusively for the WPF user interface supported by a system wide event bus. The Desktop and TenFooter applications present unique user interfaces while being supported by a common set of system components. The application designs do differ with the Desktop using a view-first style supported by the Microsoft Prism library while the TenFooter application used a model-first design supported by the Caliburn.Micro library.

The system is based upon three databases used to store the domain objects used to represent the music library, metadata gathered for artists and albums, and storage of ‘blobs’ - which are image and text files gathered from the music storage. The system supports the configuration of multiple music libraries with each music library associated with a physical location for audio file storage. The metadata is gathered from various Internet providers and shared across music libraries. Supporting files discovered within the physical storage are gathered into a blob database to facilitate perusal of a library without the physical storage of the audio files being online and available.
The primary database utilizes the Eloquera Database to store objects directly although there are also implementations that utilize Entity Framework and RavenDB. The Eloquera database was found to be the most performant for this application. The metadata uses RavenDB for storage based upon the somewhat unstructured document nature of the data gathered. The blob database is a custom file based implementation. All of the database subsystems are implemented in separate modules and utilized through an interface layer controlled by the IOC configuration. There are no direct linkages to any of the database implementation assemblies from any other system components.

The core of the music system is composed of several subsystems. 
A scanning process is used to sync the physical music storage with File and Folder domain objects within the database. A state machine based process is then used to build and maintain the associated Track, Album and Artist instances. The specific steps within the state machine are selected based upon the determination of the type of a particular file being processed - whether it is an audio file, image, or other supporting file - and a configured strategy for the music library. The strategy is used to derive information from embedded file tags as well as the structure of the music storage. For instance a typical strategy for music storage might be a root folder containing folders named after artists that contain folders named after albums containing the audio tracks for the album. The folder and file names might also contain additional information such as track numbers or album production dates.

Once the Artist, Album and Track objects are present in the library various background tasks are used to build additional information with data gathered from music sites such as Last.Fm and Discogs. Entities are associated by genre, release decade, band members and discographies. Additionally a Lucene based search index is built from all text based information to associate search terms with the primary domain objects. Audio files are also processed to determine Replay Gain levels and perhaps other quantitative information in the future such as mood or tempo.

Several components facilitate playback of the audio. At the core is a queue of playback items that may represent physical audio files or Internet streams. Maintenance of the files within the queue is supported by two sets of strategies. A playback strategy selects the order of playback from items contained by the queue. For instance playback might be in the entry order or items might be selected randomly. In addition a listener might want to inject additional tracks from a selected artist, genre, or decade. Other strategies are also available to inject ‘new releases’ (tracks recently added to the library) or ‘two-fers’ where an additional track by the same artist is played for each track played. When the tracks selected by the user have completed playing a separate ‘playback exhausted’ strategy is used to select tracks to continue playback. Various playback exhausted strategies are provided to queue tracks from a selected artist or genre, tracks from similar artists to those already selected, tracks that have seldom been played, or tracks that are favorites.
The rendering of the audio files to a system provided playback channel is accomplished with the BASS audio library that supports playback of most audio formats in common use today. In particular the system supports audio files in the wav, mp3, flac, wma and aac formats. Playback is controlled by a state machine that is exposed to the user with a standard set of transport controls.

A service interface is provided to support remote clients. The service is a self hosted WCF service with a REST interface. Support for library perusal, playback queue control and transport control is provided. Service discovery is facilitated with the Apple Bonjour implementation of the zero configuration networking standard. Currently a native iOS iPad client is available and an Android implementation is under development.

Application independent components are being factored out of the system and available in a set of ‘ReusableBits’ assemblies. There are currently several assemblies that separate the components into support for basic patterns, threading and platform support, MVVM pattern support, user interface controls, and unit testing support. These assemblies will eventually be moved to a separate repository and made available as NuGet packages. Several of the MVVM pattern components have been detailed on the blog at www.SurroundedByBraces.com

Installers are provided that utilize WiX and a custom burn process to install the Eloquera database and the Apple Bonjour service. Implementations are available in x86 or x64 compiled variations.

